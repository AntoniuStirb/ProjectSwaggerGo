/*
 * DevNest Portal API (OpenAPI 3.0)
 *
 * The DevNest Portal API endpoints definitions based on the OpenAPI 3.0 specification.
 *
 * API version: 1.0.0
 * Contact: contact@devnest.ro
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"database/sql"
	"encoding/json"
	"github.com/AntoniuStirb/ProjectSwaggerGo/database"
	"github.com/AntoniuStirb/ProjectSwaggerGo/models"
	"github.com/AntoniuStirb/ProjectSwaggerGo/service"
	_ "github.com/denisenkom/go-mssqldb"
	"github.com/gorilla/mux"
	"log"
	"net/http"
	"strconv"
)

func DeleteEmployeeById(w http.ResponseWriter, r *http.Request) {

	vars := mux.Vars(r)
	employeeID := vars["employeeId"]

	empID, err := strconv.Atoi(employeeID)
	if err != nil {
		http.Error(w, "Invalid employee id", http.StatusBadRequest)
		return
	}

	var exists bool
	err = database.DB.QueryRow("SELECT CASE WHEN EXISTS (SELECT 1 FROM employees WHERE id = @id) THEN 1 ELSE 0 END", sql.Named("id", empID)).Scan(&exists)

	if err != nil {
		log.Printf("Database error: %v", err)
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	if !exists {
		http.Error(w, "Employee not found", http.StatusNotFound)
		return
	}

	_, err = database.DB.Exec("DELETE FROM employees WHERE id = @id", sql.Named("id", empID))

	if err != nil {
		log.Printf("Database error: %v", err)
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusNoContent)
}

func EmployeesEmployeeIdPasswordPut(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func EmployeesEmployeeIdPatch(w http.ResponseWriter, r *http.Request) {

	vars := mux.Vars(r)
	employeeID := vars["employeeId"]

	empID, err := strconv.Atoi(employeeID)
	if err != nil {
		http.Error(w, "Invalid employee id", http.StatusBadRequest)
		return
	}

	//Decode the request body into the Employee struct
	var updatedEmployee models.Employee

	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&updatedEmployee); err != nil {
		http.Error(w, "Invalid request data", http.StatusBadRequest)
		return
	}

	//Check if the employee exists in the database
	var exists bool
	err = database.DB.QueryRow("SELECT CASE WHEN EXISTS (SELECT 1 FROM employees WHERE id = @id) THEN 1 ELSE 0 END", sql.Named("id", empID)).Scan(&exists)

	if err != nil {
		log.Printf("Database error: %v", err)
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	// The employee with the specified ID doesn't exist
	if !exists {
		http.Error(w, "Employee not found", http.StatusNotFound)
		return
	}

	_, err = database.DB.Exec("UPDATE employees SET status = @status WHERE id = @id", sql.Named("status", updatedEmployee.Status), sql.Named("id", empID))

	if err != nil {
		log.Printf("Database error: %v", err)
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func EmployeesEmployeeIdPut(w http.ResponseWriter, r *http.Request) {

	vars := mux.Vars(r)
	employeeID := vars["employeeId"]

	empID, err := strconv.Atoi(employeeID)
	if err != nil {
		http.Error(w, "Invalid employee id", http.StatusBadRequest)
		return
	}

	var exists bool
	err = database.DB.QueryRow("SELECT CASE WHEN EXISTS (SELECT 1 FROM employees WHERE id = @id) THEN 1 ELSE 0 END", sql.Named("id", empID)).Scan(&exists)

	if err != nil {
		log.Printf("Database error: %v", err)
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	if !exists {
		http.Error(w, "Employee not found", http.StatusNotFound)
		return
	}

	var employee models.Employee
	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&employee); err != nil {
		http.Error(w, "Invalid request data", http.StatusBadRequest)
		return
	}

	//Update the employee in the database using the provided employeeID
	_, err = database.DB.Exec(`
        UPDATE employees
			SET userId = @userId,
			firstName = @firstName,
			lastName = @lastName,
			CNP = @CNP,
			jobTitle = @jobTitle,
			city = @city,
			phoneNumber = @phoneNumber,
			workEmail = @workEmail,
			personalEmail = @personalEmail,
			employeeRateType = @employeeRateType,
			employeeRateValue = @employeeRateValue,
			contractType = @contractType,
			currency = @currency,
			vacationDays = @vacationDays,
			startingDate = @startingDate,
			endingDate = @endingDate,
			hasMedicalPackage = @hasMedicalPackage,
			status = @status
        WHERE id = @id`,
		sql.Named("userId", employee.UserId),
		sql.Named("firstName", employee.FirstName),
		sql.Named("lastName", employee.LastName),
		sql.Named("CNP", employee.CNP),
		sql.Named("jobTitle", employee.JobTitle),
		sql.Named("city", employee.City),
		sql.Named("phoneNumber", employee.PhoneNumber),
		sql.Named("workEmail", employee.WorkEmail),
		sql.Named("personalEmail", employee.PersonalEmail),
		sql.Named("employeeRateType", employee.EmployeeRateType),
		sql.Named("employeeRateValue", employee.EmployeeRateValue),
		sql.Named("contractType", employee.ContractType),
		sql.Named("currency", employee.Currency),
		sql.Named("vacationDays", employee.VacationDays),
		sql.Named("startingDate", employee.StartingDate),
		sql.Named("endingDate", employee.EndingDate),
		sql.Named("hasMedicalPackage", employee.HasMedicalPackage),
		sql.Named("status", employee.Status),
		sql.Named("id", empID), // Bind the employeeId from the request path
	)

	if err != nil {
		log.Printf("Database error: %v", err)
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func EmployeesPost(w http.ResponseWriter, r *http.Request) {
	var employee models.NewEmployee
	decoder := json.NewDecoder(r.Body)

	if err := decoder.Decode(&employee); err != nil {
		http.Error(w, "Invalid request data", http.StatusBadRequest)
		return
	}

	_, err := database.DB.Exec("INSERT INTO employees (userId, firstName, lastName, CNP, jobTitle, city, phoneNumber, workEmail, personalEmail, employeeRateType, employeeRateValue, contractType, currency, vacationDays, startingDate, endingDate, hasMedicalPackage, status) VALUES (@userId, @firstName, @lastName, @CNP, @jobTitle, @city, @phoneNumber, @workEmail, @personalEmail, @employeeRateType, @employeeRateValue, @contractType, @currency, @vacationDays, @startingDate, @endingDate, @hasMedicalPackage, @status)",
		sql.Named("userId", employee.UserId),
		sql.Named("firstName", employee.FirstName),
		sql.Named("lastName", employee.LastName),
		sql.Named("CNP", employee.CNP),
		sql.Named("jobTitle", employee.JobTitle),
		sql.Named("city", employee.City),
		sql.Named("phoneNumber", employee.PhoneNumber),
		sql.Named("workEmail", employee.WorkEmail),
		sql.Named("personalEmail", employee.PersonalEmail),
		sql.Named("employeeRateType", employee.EmployeeRateType),
		sql.Named("employeeRateValue", employee.EmployeeRateValue),
		sql.Named("contractType", employee.ContractType),
		sql.Named("currency", employee.Currency),
		sql.Named("vacationDays", employee.VacationDays),
		sql.Named("startingDate", employee.StartingDate),
		sql.Named("endingDate", employee.EndingDate),
		sql.Named("hasMedicalPackage", employee.HasMedicalPackage),
		sql.Named("status", employee.Status),
	)
	if err != nil {
		log.Printf("Database error: %v", err)
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusCreated)
}

func GetAllEmployees(w http.ResponseWriter, r *http.Request) {
	employees, err := service.GetAllEmployees()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	responseJSON, err := json.Marshal(employees)
	if err != nil {
		http.Error(w, "JSON encoding error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(responseJSON)
}

func GetEmployeeById(w http.ResponseWriter, r *http.Request) {

	vars := mux.Vars(r)
	employeeID := vars["employeeId"]

	empID, err := strconv.Atoi(employeeID)
	if err != nil {
		http.Error(w, "Invalid employee id", http.StatusBadRequest)
		return
	}

	var exists bool
	err = database.DB.QueryRow("SELECT CASE WHEN EXISTS (SELECT 1 FROM employees WHERE id = @id) THEN 1 ELSE 0 END", sql.Named("id", empID)).Scan(&exists)

	if err != nil {
		log.Printf("Database error: %v", err)
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	if !exists {
		http.Error(w, "Employee not found", http.StatusNotFound)
		return
	}

	var employee models.Employee
	err = database.DB.QueryRow("SELECT * FROM employees WHERE id = @id", sql.Named("id", empID)).Scan(
		&employee.Id,
		&employee.UserId,
		&employee.FirstName,
		&employee.LastName,
		&employee.CNP,
		&employee.JobTitle,
		&employee.City,
		&employee.PhoneNumber,
		&employee.WorkEmail,
		&employee.PersonalEmail,
		&employee.EmployeeRateType,
		&employee.EmployeeRateValue,
		&employee.ContractType,
		&employee.Currency,
		&employee.VacationDays,
		&employee.StartingDate,
		&employee.EndingDate,
		&employee.HasMedicalPackage,
		&employee.Status,
	)

	if err != nil {
		log.Printf("Database error: %v", err)
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	responseJSON, err := json.Marshal(employee)
	if err != nil {
		log.Printf("JSON encoding error: %v", err)
		http.Error(w, "JSON encoding error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(responseJSON)
}

func GetHistoryForEmployee(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}
